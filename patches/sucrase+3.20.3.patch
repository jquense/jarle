diff --git a/node_modules/sucrase/dist/parser/tokenizer/index.d.ts b/node_modules/sucrase/dist/parser/tokenizer/index.d.ts
index f7782d3..1e5e905 100644
--- a/node_modules/sucrase/dist/parser/tokenizer/index.d.ts
+++ b/node_modules/sucrase/dist/parser/tokenizer/index.d.ts
@@ -40,6 +40,7 @@ export declare class Token {
     isOptionalChainEnd: boolean;
     subscriptStartIndex: number | null;
     nullishStartIndex: number | null;
+    isTopLevel?: boolean;
 }
 export declare function next(): void;
 export declare function nextTemplateToken(): void;
diff --git a/node_modules/sucrase/dist/parser/traverser/statement.mjs b/node_modules/sucrase/dist/parser/traverser/statement.mjs
index 7969e56..4430a50 100644
--- a/node_modules/sucrase/dist/parser/traverser/statement.mjs
+++ b/node_modules/sucrase/dist/parser/traverser/statement.mjs
@@ -82,7 +82,7 @@ import {
 } from "./util";
 
 export function parseTopLevel() {
-  parseBlockBody(tt.eof);
+  parseBlockBody(tt.eof, true);
   state.scopes.push(new Scope(0, state.tokens.length, true));
   if (state.scopeDepth !== 0) {
     throw new Error(`Invalid scope depth at end of file: ${state.scopeDepth}`);
@@ -97,7 +97,7 @@ export function parseTopLevel() {
 // `if (foo) /blah/.exec(foo)`, where looking at the previous token
 // does not help.
 
-export function parseStatement(declaration) {
+export function parseStatement(declaration, isTopLevel) {
   if (isFlowEnabled) {
     if (flowTryParseStatement()) {
       return;
@@ -106,10 +106,10 @@ export function parseStatement(declaration) {
   if (match(tt.at)) {
     parseDecorators();
   }
-  parseStatementContent(declaration);
+  parseStatementContent(declaration, isTopLevel);
 }
 
-function parseStatementContent(declaration) {
+function parseStatementContent(declaration, isTopLevel = false) {
   if (isTypeScriptEnabled) {
     if (tsTryParseStatementContent()) {
       return;
@@ -117,6 +117,7 @@ function parseStatementContent(declaration) {
   }
 
   const starttype = state.type;
+  const startTokenIndex = state.tokens.length
 
   // Most types of statements are recognized by the keyword they
   // start with. Many are trivial to parse, some require a bit of
@@ -140,11 +141,13 @@ function parseStatementContent(declaration) {
       if (lookaheadType() === tt.dot) break;
       if (!declaration) unexpected();
       parseFunctionStatement();
+      state.tokens[startTokenIndex].isTopLevel = isTopLevel;
       return;
 
     case tt._class:
       if (!declaration) unexpected();
       parseClass(true);
+      state.tokens[startTokenIndex].isTopLevel = isTopLevel;
       return;
 
     case tt._if:
@@ -152,6 +155,7 @@ function parseStatementContent(declaration) {
       return;
     case tt._return:
       parseReturnStatement();
+      state.tokens[startTokenIndex].isTopLevel = isTopLevel;
       return;
     case tt._switch:
       parseSwitchStatement();
@@ -203,6 +207,7 @@ function parseStatementContent(declaration) {
         if (match(tt._function) && !canInsertSemicolon()) {
           expect(tt._function);
           parseFunction(functionStart, true);
+          state.tokens[startTokenIndex] = isTopLevel;
           return;
         } else {
           state.restoreFromSnapshot(snapshot);
@@ -227,11 +232,15 @@ function parseStatementContent(declaration) {
       simpleName = token.contextualKeyword;
     }
   }
+
+  state.tokens[startTokenIndex].isTopLevel = isTopLevel;
+  
   if (simpleName == null) {
     semicolon();
     return;
   }
   if (eat(tt.colon)) {
+    state.tokens[startTokenIndex].isTopLevel = false;
     parseLabeledStatement();
   } else {
     // This was an identifier, so we might want to handle flow/typescript-specific cases.
@@ -499,9 +508,9 @@ export function parseBlock(isFunctionScope = false, contextId = 0) {
   state.scopeDepth--;
 }
 
-export function parseBlockBody(end) {
+export function parseBlockBody(end, isTopLevel) {
   while (!eat(end) && !state.error) {
-    parseStatement(true);
+    parseStatement(true, isTopLevel);
   }
 }
 
